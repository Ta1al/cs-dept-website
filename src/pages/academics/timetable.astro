---
import Layout from '../../layouts/Layout.astro';
import Header from '@components/layout/Header.astro';
import Footer from '@components/layout/Footer.astro';
import '../../styles/global.css';
import '../../styles/timetable.css';
import fs from 'node:fs';

// Discover all JSON datasets in public/parsed at build time
const parsedDir = new URL('../../../public/parsed/', import.meta.url);
let datasetFiles: string[] = [];
let defaultDataset: string | null = null;
let datasetInfos: Record<string, string> = {};

// helper to format a timestamp relative to now (server-side)
function relativeTime(iso: string): string {
  if (!iso) return '';
  const delta = Date.now() - Date.parse(iso);
  const sec = Math.floor(delta / 1000);
  const min = Math.floor(sec / 60);
  const hr = Math.floor(min / 60);
  const day = Math.floor(hr / 24);
  if (day >= 1) return day === 1 ? '1 day ago' : `${day} days ago`;
  if (hr >= 1) return hr === 1 ? '1 hour ago' : `${hr} hours ago`;
  if (min >= 1) return min === 1 ? '1 minute ago' : `${min} minutes ago`;
  return 'just now';
}
try {
  datasetFiles = fs.readdirSync(parsedDir).filter((f) => f.endsWith('.json'));

  // read timestamp field from each JSON file; leave blank if missing
  datasetInfos = {};
  datasetFiles.forEach((f) => {
    try {
      const content = fs.readFileSync(
        new URL(`../../../public/parsed/${f}`, import.meta.url),
        'utf-8'
      );
      const obj = JSON.parse(content);
      if (obj && typeof obj.timestamp === 'string' && obj.timestamp) {
        datasetInfos[f] = obj.timestamp;
      } else {
        datasetInfos[f] = '';
      }
    } catch (e) {
      datasetInfos[f] = '';
    }
  });

  // sort by timestamp (descending). files without timestamp fall back to name
  datasetFiles.sort((a, b) => {
    const ta = datasetInfos[a];
    const tb = datasetInfos[b];
    if (ta && tb) return Date.parse(tb) - Date.parse(ta);
    if (ta) return -1; // a has timestamp, b doesn't
    if (tb) return 1; // b has timestamp
    return a.localeCompare(b);
  });

  // choose default as the first file in sorted order
  if (!defaultDataset && datasetFiles.length) {
    defaultDataset = datasetFiles[0];
  }
} catch (err) {
  console.error('Error discovering timetable datasets:', err);
}
---

<Layout>
  <Header />
  <main class="max-w-7xl mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-4">Department Timetable</h1>

    <div class="flex flex-wrap gap-3 items-center mb-4">
      <div class="flex flex-col text-sm text-gray-300">
        <label>
          Dataset
          <select
            id="dataset"
            class="ml-2 bg-gray-800 border border-gray-700 rounded px-2 py-1"
          >
            {
              datasetFiles.map((f) => (
                <option
                  value={f}
                  selected={f === defaultDataset}
                  data-updated={datasetInfos[f] || ''}
                >
                  {f}
                </option>
              ))
            }
          </select>
        </label>
        <p
          id="last-updated"
          class="text-xs text-gray-400 mt-1"
          title={defaultDataset && datasetInfos[defaultDataset]
            ? new Date(datasetInfos[defaultDataset]).toLocaleString()
            : ''}
        >
          {
            defaultDataset && datasetInfos[defaultDataset]
              ? `Last updated: ${relativeTime(datasetInfos[defaultDataset])}`
              : ''
          }
        </p>
      </div>

      <div class="relative">
        <input
          id="search"
          type="text"
          placeholder="Search course, teacher, room..."
          class="bg-gray-800 border border-gray-700 rounded pl-3 pr-3 py-1.5 w-72"
        />
      </div>

      <button
        id="toggle-simplified"
        aria-pressed="false"
        class="simplified-switch group ml-auto hidden lg:block"
      >
        <span class="switch-track"></span>
        <span class="switch-thumb"></span>
        <span class="switch-label">Simplified View</span>
      </button>

      <button
        id="export-google-calendar"
        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-all duration-200 flex items-center gap-2 text-sm font-medium"
        title="Export filtered results to Google Calendar"
      >
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
          <path
            d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"
          ></path>
        </svg>
        <span>Export to Calendar</span>
      </button>
      <button
        id="export-image"
        class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-all duration-200 flex items-center gap-2 text-sm font-medium"
        title="Download an image of filtered classes"
      >
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
          <path d="M5 7h14v10H5V7zm7 8a3 3 0 100-6 3 3 0 000 6z"></path>
        </svg>
        <span>Export to Image</span>
      </button>
    </div>

    <div class="flex justify-between items-center" id="filter-toggle-wrapper">
      <button
        id="mobile-filter-toggle"
        class="text-xs tracking-wide font-semibold flex items-center gap-2 px-3 py-2 rounded-md bg-gray-800/70 border border-gray-700 hover:border-gray-500 hover:bg-gray-700/70 transition"
      >
        <span>Filters</span>
        <span
          id="mobile-filter-count"
          class="inline-flex items-center justify-center text-[10px] font-bold bg-blue-600/70 text-white rounded-full min-w-[1.25rem] h-5 px-1"
        ></span>
        <svg
          id="mobile-filter-caret"
          class="w-3.5 h-3.5 opacity-70"
          viewBox="0 0 20 20"
          fill="currentColor"
        >
          <path
            fill-rule="evenodd"
            d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.08 1.04l-4.25 4.25a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z"
            clip-rule="evenodd"></path>
        </svg>
      </button>
    </div>

    <div
      id="filters"
      class="collapsed space-y-2 flex flex-col items-stretch max-w-4xl mx-auto md:mt-0 mt-2"
    >
      <div id="day-filters" class="filter-row"></div>
      <div id="degree-filters" class="filter-row"></div>
      <div id="program-filters" class="filter-row"></div>
      <div id="semester-filters" class="filter-row"></div>
      <div id="section-filters" class="filter-row"></div>
      <div class="pt-2 flex justify-center">
        <button id="clear-filters" class="clear-btn">Clear Filters</button>
      </div>
    </div>

    <div
      id="export-area"
      class="bg-gray-900/60 backdrop-blur rounded-xl border border-gray-800 shadow-xl overflow-hidden"
    >
      <div class="max-h-[60vh] overflow-auto" id="results-wrapper">
        <table class="min-w-full text-sm table-fixed align-top">
          <colgroup>
            <col style="width: 11rem;" />
            <col style="width: 20rem;" />
            <col style="width: 7rem;" />
            <col style="width: 18rem;" />
            <col style="width: 14rem;" />
            <col style="width: 8rem;" />
            <col style="width: 7rem;" />
            <col style="width: 14rem;" />
          </colgroup>
          <thead
            class="bg-gray-800/70 text-gray-300 sticky top-0 z-10 backdrop-blur supports-[backdrop-filter]:bg-gray-800/60"
          >
            <tr class="text-left">
              <th class="px-3 py-2 font-medium" data-sort="start_time">Time</th>
              <th class="px-3 py-2 font-medium" data-sort="course_title"
                >Course</th
              >
              <th class="px-3 py-2 font-medium" data-sort="course_code">Code</th
              >
              <th class="px-3 py-2 font-medium" data-sort="program_line"
                >Program / Semester</th
              >
              <th class="px-3 py-2 font-medium" data-sort="teacher_name"
                >Teacher</th
              >
              <th class="px-3 py-2 font-medium" data-sort="room">Room</th>
              <th class="px-3 py-2 font-medium" data-sort="day">Day</th>
              <th class="px-3 py-2 font-medium">Flags</th>
            </tr>
          </thead>
          <tbody id="results" class="divide-y divide-gray-800"></tbody>
        </table>
      </div>
    </div>
    <div id="mobile-results" class="mt-6 space-y-3"></div>
  </main>
  <Footer />
</Layout>

<script>
  // Re-bind imported utilities (Astro frontmatter imports are server-side; re-import for client script)
  import { DAY_ORDER, to12, buildClassShort } from '../../utils/timetableUtils';

  // (timestamps stored on option elements via data-updated)
  // --- Type Definitions ---
  interface RawEntry {
    combined_class: boolean | null;
    course_title: string | null;
    course_code: string | null;
    program_line: string | null;
    degree: string | null;
    program: string | null;
    section: string | null;
    session: string | null;
    semester: number | null;
    teacher_name: string | null;
    start_time: string | null;
    end_time: string | null;
    practical: boolean | null;
    raw_lines?: string[];
  }
  interface FlatRecord {
    day: string;
    room: string;
    course_title: string;
    course_code: string;
    program_line: string;
    degree: string;
    program: string;
    section: string;
    session: string;
    semester: number | null;
    teacher_name: string;
    combined_class: boolean | null;
    start_time: string;
    end_time: string;
    practical: boolean | null | undefined;
    raw: string[];
  }

  // Element refs (narrowed to specific types)
  const datasetSelect = document.getElementById(
    'dataset'
  ) as HTMLSelectElement | null;
  const searchInput = document.getElementById(
    'search'
  ) as HTMLInputElement | null;
  const resultsEl = document.getElementById(
    'results'
  ) as HTMLTableSectionElement | null;

  const mobileResultsEl = document.getElementById(
    'mobile-results'
  ) as HTMLElement | null;
  const simplifiedToggle = document.getElementById(
    'toggle-simplified'
  ) as HTMLButtonElement | null;
  const dayFiltersEl = document.getElementById(
    'day-filters'
  ) as HTMLElement | null;
  const semesterFiltersEl = document.getElementById(
    'semester-filters'
  ) as HTMLElement | null;
  const programFiltersEl = document.getElementById(
    'program-filters'
  ) as HTMLElement | null;
  const sectionFiltersEl = document.getElementById(
    'section-filters'
  ) as HTMLElement | null;
  const degreeFiltersEl = document.getElementById(
    'degree-filters'
  ) as HTMLElement | null;

  type RawData = Record<string, Record<string, RawEntry[]>>;
  let rawData: RawData = {} as RawData; // initial nested data with day->room->entries
  let flat: FlatRecord[] = []; // flattened records array
  const activeDays = new Set<string>();
  const activeSemesters = new Set<string>();
  const activePrograms = new Set<string>();
  const activeSections = new Set<string>();
  const activeDegrees = new Set<string>();

  // DAY_ORDER & to12 now imported from timetableUtils

  function makeButton(
    label: string,
    container: HTMLElement | null,
    set: Set<string>,
    displayLabel?: string
  ): void {
    if (!container) return;
    const btn = document.createElement('button');
    btn.type = 'button';
    // Use displayLabel (e.g., 'Semester 4') for text while keeping raw label for filter set
    btn.textContent = displayLabel || label;
    btn.dataset.filterValue = label;
    const base = 'chip';
    const inactive = 'chip-inactive';
    // contextual color accent based on row type
    let accent = '';
    if (container.id === 'day-filters') accent = 'chip-accent-day';
    else if (container.id === 'degree-filters') accent = 'chip-accent-degree';
    else if (container.id === 'program-filters') accent = 'chip-accent-program';
    else if (container.id === 'semester-filters')
      accent = 'chip-accent-semester';
    else if (container.id === 'section-filters') accent = 'chip-accent-section';
    const activeClasses = ['chip-active'];
    const isActive = set.has(label);
    btn.className =
      base +
      ' ' +
      accent +
      ' ' +
      (isActive ? activeClasses.join(' ') : inactive);
    btn.addEventListener('click', () => {
      const key = btn.dataset.filterValue || label;
      if (set.has(key)) set.delete(key);
      else set.add(key);
      const active = set.has(key);
      if (active) {
        activeClasses.forEach((c) => btn.classList.add(c));
        btn.classList.remove('chip-inactive');
      } else {
        activeClasses.forEach((c) => btn.classList.remove(c));
        btn.classList.add('chip-inactive');
      }
      render();
      updateActiveCountBadge();
    });
    container.appendChild(btn);
  }

  async function loadDataset(name: string): Promise<void> {
    if (resultsEl)
      resultsEl.innerHTML =
        '<tr><td class="px-4 py-6 text-center text-gray-400" colspan="8">Loading...</td></tr>';
    try {
      const res = await fetch(`/parsed/${name}`);
      rawData = await res.json();
      flatten();
      buildFilters();
      render();
      updateActiveCountBadge();
    } catch (err) {
      if (resultsEl)
        resultsEl.innerHTML = `<tr><td class='px-4 py-6 text-center text-red-400' colspan='8'>Failed to load dataset: ${err}</td></tr>`;
    }
  }

  function flatten(): void {
    flat = [];
    Object.entries(rawData).forEach(([day, rooms]) => {
      Object.entries(rooms).forEach(([room, entries]) => {
        if (!Array.isArray(entries)) return;
        entries.forEach((entry) => {
          if (!entry) return;
          const rec: FlatRecord = {
            day,
            room,
            course_title: entry.course_title || '',
            course_code: entry.course_code || '',
            program_line: entry.program_line || '',
            degree: entry.degree || '',
            program: entry.program || '',
            section: entry.section || '',
            session: entry.session || '',
            semester: entry.semester ?? null,
            teacher_name: entry.teacher_name || '',
            combined_class: entry.combined_class ?? null,
            start_time: entry.start_time || '',
            end_time: entry.end_time || '',
            practical:
              (entry.practical ?? false) &&
              (entry.raw_lines?.some((l: string) => /practical/i.test(l)) ||
                entry.practical),
            raw: entry.raw_lines || [],
          };
          const meaningful = rec.course_title && rec.course_title !== '';
          if (meaningful || rec.teacher_name || rec.program_line)
            flat.push(rec);
        });
      });
    });
  }

  function buildFilters(): void {
    if (dayFiltersEl) dayFiltersEl.innerHTML = '';
    if (degreeFiltersEl) degreeFiltersEl.innerHTML = '';
    if (programFiltersEl) programFiltersEl.innerHTML = '';
    if (semesterFiltersEl) semesterFiltersEl.innerHTML = '';
    if (sectionFiltersEl) sectionFiltersEl.innerHTML = '';

    const days = [...new Set(flat.map((r) => r.day))].sort(
      (a, b) => DAY_ORDER.indexOf(a) - DAY_ORDER.indexOf(b)
    );
    const semesters = [
      ...new Set(flat.map((r) => r.semester).filter((v) => v != null)),
    ].sort((a, b) => (Number(a) as number) - (Number(b) as number));
    const programs = [
      ...new Set(flat.map((r) => r.program).filter(Boolean)),
    ].sort();
    const degrees = [
      ...new Set(flat.map((r) => r.degree).filter(Boolean)),
    ].sort();

    days.forEach((d) => makeButton(d, dayFiltersEl, activeDays));
    // Degrees row (explicit BS, MS, PhD ordering if present)
    const DEG_ORDER = ['BS', 'MS', 'PhD'];
    const orderedDegrees = degrees.sort((a, b) => {
      const ai = DEG_ORDER.indexOf(a.toUpperCase());
      const bi = DEG_ORDER.indexOf(b.toUpperCase());
      if (ai === -1 && bi === -1) return a.localeCompare(b);
      if (ai === -1) return 1;
      if (bi === -1) return -1;
      return ai - bi;
    });
    orderedDegrees.forEach((dg) =>
      makeButton(dg, degreeFiltersEl, activeDegrees)
    );
    programs.forEach((p) => makeButton(p, programFiltersEl, activePrograms));
    semesters.forEach((s) =>
      makeButton(String(s), semesterFiltersEl, activeSemesters, `Semester ${s}`)
    );
    // Sections: only show if multiple distinct non-empty sections exist
    const sections = [
      ...new Set(flat.map((r) => r.section).filter(Boolean)),
    ].sort();
    if (sections.length > 1) {
      sections.forEach((sec) =>
        makeButton(sec, sectionFiltersEl, activeSections)
      );
    }
  }

  function recordMatches(rec: FlatRecord, q: string): boolean {
    if (!q) return true;
    const hay = [
      rec.course_title,
      rec.course_code,
      rec.program_line,
      rec.degree,
      rec.program,
      rec.section,
      rec.session,
      rec.teacher_name,
      rec.room,
      rec.day,
      String(rec.semester || ''),
    ]
      .join(' ')
      .toLowerCase();
    return q.split(/\s+/).every((term: string) => hay.includes(term));
  }

  function applyFilters(list: FlatRecord[]): FlatRecord[] {
    return list.filter((r: FlatRecord) => {
      if (activeDays.size && !activeDays.has(r.day)) return false;
      if (activeSemesters.size && !activeSemesters.has(String(r.semester)))
        return false;
      if (activePrograms.size && !activePrograms.has(r.program)) return false;
      if (activeSections.size && !activeSections.has(r.section)) return false;
      if (activeDegrees.size && !activeDegrees.has(r.degree)) return false;
      return true;
    });
  }

  let sortKey: keyof FlatRecord | 'day' = 'day';
  let sortDir: 1 | -1 = 1;
  let debounceTimer: number | null = null;

  function headerSortHandler(th: HTMLElement, key: keyof FlatRecord | 'day') {
    th.addEventListener('click', () => {
      if (sortKey === key) {
        sortDir = sortDir === 1 ? -1 : 1;
      } else {
        sortKey = key;
        sortDir = 1;
      }
      render();
    });
  }

  function attachHeaderSorting() {
    document.querySelectorAll('thead th').forEach((th) => {
      const key = (th as HTMLElement).dataset.sort as
        | keyof FlatRecord
        | 'day'
        | undefined;
      if (key) {
        headerSortHandler(th as HTMLElement, key);
      }
    });
  }

  function syncURL() {
    const params = new URLSearchParams();
    if (datasetSelect?.value) params.set('ds', datasetSelect.value);
    const q = searchInput?.value?.trim();
    if (q) params.set('q', q);
    if (activeDays.size) params.set('days', [...activeDays].join('|'));
    if (activeSemesters.size) params.set('sem', [...activeSemesters].join('|'));
    if (activePrograms.size) params.set('prog', [...activePrograms].join('|'));
    if (activeSections.size) params.set('sec', [...activeSections].join('|'));
    if (activeDegrees.size) params.set('deg', [...activeDegrees].join('|'));
    if (sortKey) params.set('sort', sortKey);
    if (sortDir === -1) params.set('dir', 'desc');
    if (document.documentElement.classList.contains('simplified'))
      params.set('mode', 'simple');
    // grouping removed
    const newUrl = `${location.pathname}?${params.toString()}`;
    history.replaceState(null, '', newUrl);
  }

  function loadFromURL() {
    const params = new URLSearchParams(location.search);
    const ds = params.get('ds');
    if (ds && datasetSelect) datasetSelect.value = ds;
    const q = params.get('q');
    if (q && searchInput) searchInput.value = q;
    const days = params.get('days');
    if (days) days.split('|').forEach((d) => activeDays.add(d));
    const sem = params.get('sem');
    if (sem) sem.split('|').forEach((s) => activeSemesters.add(s));
    const prog = params.get('prog');
    if (prog) prog.split('|').forEach((p) => activePrograms.add(p));
    const sec = params.get('sec');
    if (sec) sec.split('|').forEach((s) => activeSections.add(s));
    const deg = params.get('deg');
    if (deg) deg.split('|').forEach((d) => activeDegrees.add(d));
    const sk = params.get('sort') as keyof FlatRecord | 'day' | null;
    if (sk) sortKey = sk;
    const sd = params.get('dir');
    if (sd === 'desc') sortDir = -1;
    const mode = params.get('mode');
    if (mode === 'simple' || !mode) {
      // Default to simplified when param missing or explicitly simple
      document.documentElement.classList.add('simplified');
      if (simplifiedToggle) {
        simplifiedToggle.classList.add('active');
        simplifiedToggle.setAttribute('aria-pressed', 'true');
      }
      // If param was missing, reflect it in URL after initial render
    }
    // grouping removed
  }

  function render(): void {
    const q = (searchInput?.value || '').trim().toLowerCase();
    const list = applyFilters(flat).filter((r: FlatRecord) =>
      recordMatches(r, q)
    );
    list.sort((a: FlatRecord, b: FlatRecord) => {
      // Sort priority: chosen sortKey then fallback original ordering logic
      const primary = (() => {
        if (sortKey === 'day')
          return DAY_ORDER.indexOf(a.day) - DAY_ORDER.indexOf(b.day);
        const av = (a as unknown as Record<string, unknown>)[sortKey];
        const bv = (b as unknown as Record<string, unknown>)[sortKey];
        if (typeof av === 'number' && typeof bv === 'number') return av - bv;
        return String(av).localeCompare(String(bv));
      })();
      if (primary !== 0) return primary * sortDir;
      const dayDiff = DAY_ORDER.indexOf(a.day) - DAY_ORDER.indexOf(b.day);
      if (dayDiff !== 0) return dayDiff;
      const tA = a.start_time
        ? parseInt(a.start_time.slice(0, 2)) * 60 +
          parseInt(a.start_time.slice(3, 5))
        : 0;
      const tB = b.start_time
        ? parseInt(b.start_time.slice(0, 2)) * 60 +
          parseInt(b.start_time.slice(3, 5))
        : 0;
      if (tA !== tB) return tA - tB;
      if (a.room < b.room) return -1;
      if (a.room > b.room) return 1;
      return 0;
    });
    // Desktop table rows
    const rows = list
      .map((r: FlatRecord) => {
        const flags: string[] = [];
        if (r.combined_class) flags.push('Combined');
        if (r.practical) flags.push('Practical');
        const timeStr = `${to12(r.start_time)}${r.end_time ? ` - ${to12(r.end_time)}` : ''}`;
        const classBase = buildClassShort(r);
        const semSuffix = r.semester != null ? ` (Sem #${r.semester})` : '';
        const classLine = classBase + semSuffix;
        return `<tr>
          <td data-label="Time" class="px-3 py-2 text-gray-300">${timeStr}</td>
          <td data-label="Course" class="px-3 py-2 text-gray-200">${r.course_title || '<span class="text-gray-500">TBA</span>'}</td>
          <td data-label="Code" class="px-3 py-2 text-gray-400">${r.course_code || ''}</td>
          <td data-label="Program / Semester" class="px-3 py-2 text-gray-300">
            <div>${classLine}</div>
            <div class="text-xs">Semester ${r.semester ?? ''} ${r.section ? '• ' + r.section : ''}</div>
          </td>
          <td data-label="Teacher" class="px-3 py-2 text-gray-300">${r.teacher_name || ''}</td>
          <td data-label="Room" class="px-3 py-2 text-gray-400">${r.room}</td>
          <td data-label="Day" class="px-3 py-2 text-gray-400">${r.day}</td>
          <td data-label="Flags" class="px-3 py-2 text-xs">${flags
            .map(
              (f) =>
                `<span class='inline-block bg-blue-600/30 border border-blue-500/40 text-blue-300 rounded-full px-2 py-0.5 mr-1 mb-1'>${f}</span>`
            )
            .join('')}</td>
        </tr>`;
      })
      .join('');
    if (resultsEl)
      resultsEl.innerHTML =
        rows ||
        `<tr><td class='px-4 py-6 text-center text-gray-400' colspan='8'>No matching results</td></tr>`;

    // Mobile simplified cards
    if (mobileResultsEl) {
      const mobileCards = list
        .map((r: FlatRecord) => {
          const classBase = buildClassShort(r);
          const semSuffix = r.semester != null ? ` (Sem #${r.semester})` : '';
          const classLine = classBase + semSuffix;
          const timeStr = `${to12(r.start_time)}${r.end_time ? ` - ${to12(r.end_time)}` : ''}`;
          const flags: string[] = [];
          if (r.combined_class) flags.push('Combined');
          if (r.practical) flags.push('Practical');
          const flagsHTML = flags.length
            ? `<div class="mcard-meta-flags">${flags
                .map((f) => `<span class="mcard-flag">${f}</span>`)
                .join('')}</div>`
            : '';
          return `<div class="mcard">
            <div class="mcard-meta">
              <div class="mcard-meta-day">${r.day}</div>
              <div class="mcard-meta-time">${timeStr}</div>
              ${flagsHTML}
            </div>
            <div class="mcard-course">${r.course_title || '<span class="text-gray-500">TBA</span>'}</div>
            <div class="mcard-class">${classLine}</div>
            <div class="mcard-teacher">${r.teacher_name || ''}</div>
            <div class="mcard-room">${r.room || ''}</div>
          </div>`;
        })
        .join('');
      mobileResultsEl.innerHTML = mobileCards;
    }
    syncURL();
    updateActiveCountBadge();
  }

  function clearAll() {
    activeDays.clear();
    activeSemesters.clear();
    activePrograms.clear();
    activeSections.clear();
    activeDegrees.clear();
    if (searchInput) searchInput.value = '';
    buildFilters();
    render();
  }

  if (datasetSelect)
    datasetSelect.addEventListener('change', () => {
      if (datasetSelect) {
        loadDataset(datasetSelect.value);
        updateLastModified(datasetSelect.value);
      }
    });
  if (searchInput)
    searchInput.addEventListener('input', () => {
      if (debounceTimer) window.clearTimeout(debounceTimer);
      debounceTimer = window.setTimeout(() => {
        render();
      }, 60);
    });

  document.getElementById('clear-filters')?.addEventListener('click', clearAll);
  loadFromURL();

  if (datasetSelect instanceof HTMLSelectElement) {
    loadDataset(datasetSelect.value).then(() => {
      attachHeaderSorting();
      updateLastModified(datasetSelect.value);
    });
  }

  // Mobile filter toggle
  const mobileToggle = document.getElementById('mobile-filter-toggle');
  const filtersContainer = document.getElementById('filters');
  const mobileCount = document.getElementById('mobile-filter-count');

  function countActiveFilters(): number {
    return (
      activeDays.size +
      activeSemesters.size +
      activePrograms.size +
      activeSections.size +
      activeDegrees.size
    );
  }
  function updateActiveCountBadge() {
    if (!mobileCount) return;
    const c = countActiveFilters();
    mobileCount.textContent = c ? String(c) : '';
    mobileCount.style.display = c ? 'inline-flex' : 'none';
  }
  updateActiveCountBadge();

  mobileToggle?.addEventListener('click', () => {
    if (!filtersContainer) return;
    const collapsed = filtersContainer.classList.toggle('collapsed');
    mobileToggle.classList.toggle('active', !collapsed);
  });
  if (filtersContainer?.classList.contains('collapsed')) {
    mobileToggle?.classList.remove('active');
  }
  function autoExpandFiltersForTablet() {
    if (!filtersContainer) return;
    const w = window.innerWidth;
    if (w >= 768 && w <= 820) {
      if (filtersContainer.classList.contains('collapsed')) {
        filtersContainer.classList.remove('collapsed');
        mobileToggle?.classList.add('active');
      }
    }
  }
  autoExpandFiltersForTablet();
  window.addEventListener('resize', () => {
    autoExpandFiltersForTablet();
  });

  // helper to compute relative time (client-side)
  function relativeTimeClient(iso: string): string {
    const delta = Date.now() - Date.parse(iso);
    const sec = Math.floor(delta / 1000);
    const min = Math.floor(sec / 60);
    const hr = Math.floor(min / 60);
    const day = Math.floor(hr / 24);
    if (day >= 1) return day === 1 ? '1 day ago' : `${day} days ago`;
    if (hr >= 1) return hr === 1 ? '1 hour ago' : `${hr} hours ago`;
    if (min >= 1) return min === 1 ? '1 minute ago' : `${min} minutes ago`;
    return 'just now';
  }

  // helper to update the "last updated" UI
  function updateLastModified(filename: string) {
    const el = document.getElementById('last-updated');
    if (!el) return;
    let ts = '';
    const sel = datasetSelect as HTMLSelectElement | null;
    if (sel) {
      const opt = sel.querySelector(`option[value="${filename}"]`);
      if (opt) ts = opt.getAttribute('data-updated') || '';
    }
    if (ts) {
      const d = new Date(ts);
      el.textContent = 'Last updated: ' + relativeTimeClient(ts);
      el.title = d.toLocaleString();
    } else {
      el.textContent = '';
      el.title = '';
    }
  }

  simplifiedToggle?.addEventListener('click', () => {
    document.documentElement.classList.toggle('simplified');
    const active = document.documentElement.classList.contains('simplified');
    simplifiedToggle.classList.toggle('active', active);
    simplifiedToggle.setAttribute('aria-pressed', active ? 'true' : 'false');
    render();
  });

  // .ics Calendar Export functionality
  const exportButton = document.getElementById('export-google-calendar');

  function getDayOffset(dayName: string): number {
    const days = [
      'Sunday',
      'Monday',
      'Tuesday',
      'Wednesday',
      'Thursday',
      'Friday',
      'Saturday',
    ];
    return days.indexOf(dayName);
  }

  function getNextOccurrence(dayName: string): Date {
    const today = new Date();
    const targetDay = getDayOffset(dayName);
    const currentDay = today.getDay();
    let daysUntilTarget = targetDay - currentDay;

    if (daysUntilTarget <= 0) {
      daysUntilTarget += 7;
    }

    const nextDate = new Date(today);
    nextDate.setDate(today.getDate() + daysUntilTarget);
    return nextDate;
  }

  function formatDateForICS(date: Date, time: string): string {
    const [hours, minutes] = time.split(':').map(Number);
    const newDate = new Date(date);
    newDate.setHours(hours, minutes, 0, 0);

    // Format: YYYYMMDDTHHmmSS
    const year = newDate.getFullYear();
    const month = String(newDate.getMonth() + 1).padStart(2, '0');
    const day = String(newDate.getDate()).padStart(2, '0');
    const hour = String(newDate.getHours()).padStart(2, '0');
    const minute = String(newDate.getMinutes()).padStart(2, '0');

    return `${year}${month}${day}T${hour}${minute}00`;
  }

  function createICSEvent(record: FlatRecord): string {
    // Get the next occurrence of this class day
    const classDate = getNextOccurrence(record.day);

    // Format start and end times
    const startTime = formatDateForICS(classDate, record.start_time);
    const endTime = formatDateForICS(
      classDate,
      record.end_time || record.start_time
    );

    // Build title and description
    const title = record.course_title || 'Class';
    const description = [
      record.course_code ? `Course Code: ${record.course_code}` : '',
      record.teacher_name ? `Teacher: ${record.teacher_name}` : '',
      record.program_line ? `Program: ${record.program_line}` : '',
      record.semester ? `Semester: ${record.semester}` : '',
      record.section ? `Section: ${record.section}` : '',
      record.practical ? 'Type: Practical' : '',
      record.combined_class ? 'Type: Combined Class' : '',
    ]
      .filter(Boolean)
      .join('\\n');

    const location = `Room ${record.room}`;

    // Generate unique ID for this event
    const uid = `${record.course_code}-${record.day}-${record.start_time}-${Date.now()}@cs-dept.edu`;

    // Get current timestamp for DTSTAMP
    const now = new Date();
    const dtstamp = formatDateForICS(
      now,
      `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`
    );

    return `BEGIN:VEVENT
UID:${uid}
DTSTAMP:${dtstamp}
DTSTART:${startTime}
DTEND:${endTime}
SUMMARY:${title}
DESCRIPTION:${description}
LOCATION:${location}
STATUS:CONFIRMED
SEQUENCE:0
END:VEVENT`;
  }

  function generateICSFile(records: FlatRecord[]): string {
    const events = records.map(createICSEvent).join('\n');

    return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//CS Department//Timetable//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:CS Department Timetable
X-WR-TIMEZONE:Asia/Karachi
${events}
END:VCALENDAR`;
  }

  function downloadICS(content: string, filename: string): void {
    const blob = new Blob([content], { type: 'text/calendar;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
  }

  exportButton?.addEventListener('click', () => {
    // Get currently filtered results
    const q = (searchInput?.value || '').trim().toLowerCase();
    const filteredList = applyFilters(flat).filter((r: FlatRecord) =>
      recordMatches(r, q)
    );

    if (filteredList.length === 0) {
      alert('No timetable entries to export. Please adjust your filters.');
      return;
    }

    // Group by similar classes to avoid duplicates
    const uniqueClasses = new Map<string, FlatRecord>();

    filteredList.forEach((record: FlatRecord) => {
      // Create a unique key for each class
      const key = `${record.course_code}-${record.day}-${record.start_time}-${record.room}`;
      if (!uniqueClasses.has(key)) {
        uniqueClasses.set(key, record);
      }
    });

    // Generate and download .ics file
    const uniqueRecords = Array.from(uniqueClasses.values());
    const icsContent = generateICSFile(uniqueRecords);
    const filename = `timetable-${new Date().toISOString().split('T')[0]}.ics`;

    downloadICS(icsContent, filename);

    alert(
      `Exported ${uniqueClasses.size} class${uniqueClasses.size === 1 ? '' : 'es'} to ${filename}. You can import this file into Google Calendar, Apple Calendar, Outlook, or any other calendar application.`
    );
  });

  // image export handler
  const exportImageButton = document.getElementById('export-image');

  // helper to render table data into a canvas and return blob
  async function generateTablePNG(
    records: FlatRecord[],
    footerText = ''
  ): Promise<Blob> {
    // sort by day order then start time
    records.sort((a, b) => {
      const dayA = DAY_ORDER.indexOf(a.day);
      const dayB = DAY_ORDER.indexOf(b.day);
      if (dayA !== dayB) return dayA - dayB;
      const tA = a.start_time
        ? parseInt(a.start_time.slice(0, 2)) * 60 +
          parseInt(a.start_time.slice(3, 5))
        : 0;
      const tB = b.start_time
        ? parseInt(b.start_time.slice(0, 2)) * 60 +
          parseInt(b.start_time.slice(3, 5))
        : 0;
      return tA - tB;
    });

    // build headers; include flags column only if needed
    const headers = [
      'Day',
      'Time',
      'Course',
      'Teacher',
      'Room',
      'Program / Semester',
      'Flags',
    ];

    // convert records into rows, leaving day blank for repeats
    const data: string[][] = [];
    let lastDay = '';
    let anyFlags = false;
    for (const r of records) {
      const timeStr = `${to12(r.start_time)}${
        r.end_time ? ` - ${to12(r.end_time)}` : ''
      }`;
      const classBase = buildClassShort(r);
      const semSuffix = r.semester != null ? ` (Sem #${r.semester})` : '';
      const classLine = classBase + semSuffix;
      const flagsArr: string[] = [];
      if (r.combined_class) flagsArr.push('Combined');
      if (r.practical) flagsArr.push('Practical');
      const flagsStr = flagsArr.join(', ');
      if (flagsStr) anyFlags = true;
      const dayDisplay = r.day === lastDay ? '' : r.day;
      lastDay = r.day;
      data.push([
        dayDisplay,
        timeStr,
        r.course_title || 'TBA',
        r.teacher_name || '',
        r.room,
        classLine,
        flagsStr,
      ]);
    }

    // if no flags present in any row, drop the last column and header
    if (!anyFlags) {
      headers.pop();
      data.forEach((row) => row.pop());
    }

    const padding = 8;
    const rowHeight = 24;
    const headerHeight = 32;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Unable to create canvas context');
    ctx.font = '14px system-ui';

    // compute widths
    const colWidths = headers.map((h, i) => {
      let w = ctx.measureText(h).width;
      data.forEach((row) => {
        w = Math.max(w, ctx.measureText(String(row[i])).width);
      });
      return w + padding * 2;
    });

    const totalWidth = colWidths.reduce((a, b) => a + b, 0);
    const footerHeight = footerText ? 24 : 0;
    const totalHeight = headerHeight + data.length * rowHeight + footerHeight;
    canvas.width = totalWidth;
    canvas.height = totalHeight;

    ctx.fillStyle = '#1f1f1f';
    ctx.fillRect(0, 0, totalWidth, totalHeight);

    // header
    ctx.fillStyle = '#374151';
    ctx.fillRect(0, 0, totalWidth, headerHeight);
    ctx.fillStyle = '#f3f4f6';
    ctx.font = 'bold 14px system-ui';
    let x = 0;
    headers.forEach((h, i) => {
      ctx.fillText(h, x + padding, headerHeight - 8);
      x += colWidths[i];
    });

    // rows
    ctx.font = '14px system-ui';
    data.forEach((row, ridx) => {
      const y = headerHeight + ridx * rowHeight;
      ctx.fillStyle = ridx % 2 === 0 ? '#1f1f1f' : '#111827';
      ctx.fillRect(0, y, totalWidth, rowHeight);
      ctx.fillStyle = '#f9fafb';
      let xx = 0;
      row.forEach((cell, i) => {
        ctx.fillText(cell, xx + padding, y + rowHeight - 8);
        xx += colWidths[i];
      });
    });

    // footer text at bottom left (below rows)
    if (footerText) {
      ctx.fillStyle = 'rgba(243,244,246,0.6)'; // lighter opacity
      ctx.font = '12px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(
        footerText,
        padding,
        headerHeight + data.length * rowHeight + (footerHeight - 8)
      );
    }

    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) resolve(blob);
        else reject(new Error('Canvas toBlob returned null'));
      });
    });
  }

  exportImageButton?.addEventListener('click', async () => {
    const q = (searchInput?.value || '').trim().toLowerCase();
    const filteredList = applyFilters(flat).filter((r: FlatRecord) =>
      recordMatches(r, q)
    );

    if (filteredList.length === 0) {
      alert('No timetable entries to export. Please adjust your filters.');
      return;
    }

    try {
      // build footer with current domain and optional dataset timestamp
      let footer = `Generated from ${location.hostname}`;
      const sel = document.getElementById(
        'dataset'
      ) as HTMLSelectElement | null;
      if (sel) {
        const opt = sel.options[sel.selectedIndex];
        const ts = opt?.getAttribute('data-updated') || '';
        if (ts) {
          const d = new Date(ts);
          footer += ` • Last updated at ${d.toLocaleString()}`;
        }
      }
      const blob = await generateTablePNG(filteredList, footer);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `timetable-${new Date().toISOString().split('T')[0]}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      alert(
        `Downloaded image containing ${filteredList.length} row${
          filteredList.length === 1 ? '' : 's'
        }.`
      );
    } catch (err) {
      console.error('image export error', err);
      alert('Failed to generate timetable image.');
    }
  });
</script>
